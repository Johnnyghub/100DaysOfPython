# -*- coding: utf-8 -*-
"""Lego Analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-UMtXCEktJ-lUf3yf_c1VbHXG_TY1tW-

# Introduction

Today we'll dive deep into a dataset all about LEGO. From the dataset we can ask whole bunch of interesting questions about the history of the LEGO company, their product offering, and which LEGO set ultimately rules them all:

<ul type="square">
<li>What is the most enormous LEGO set ever created and how many parts did it have?</li>

<li>How did the LEGO company start out? In which year were the first LEGO sets released and how many sets did the company sell when it first launched?</li>

<li>Which LEGO theme has the most sets? Is it one of LEGO's own themes like Ninjago or a theme they licensed liked Harry Potter or Marvel Superheroes?</li>

<li>When did the LEGO company really expand its product offering? Can we spot a change in the company strategy based on how many themes and sets did it released year-on-year?</li>

<li>Did LEGO sets grow in size and complexity over time? Do older LEGO 
sets tend to have more or fewer parts than newer sets?</li>
</ul>

**Data Source**

[Rebrickable](https://rebrickable.com/downloads/) has compiled data on all the LEGO pieces in existence. I recommend you use download the .csv files provided in this lesson.

<img src="https://i.imgur.com/49FNOHj.jpg">

# Import Statements
"""

import pandas as pd
import matplotlib.pyplot as plt

"""# Data Exploration

**Challenge**: How many different colours does the LEGO company produce? Read the colors.csv file in the data folder and find the total number of unique colours. Try using the [.nunique() method](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.nunique.html?highlight=nunique#pandas.DataFrame.nunique) to accomplish this.
"""

colors_df = pd.read_csv("data/colors.csv")
colors_df

print(f"There are {colors_df.name.nunique()} different colors of legos!")

"""**Challenge**: Find the number of transparent colours where <code>is_trans == 't'</code> versus the number of opaque colours where <code>is_trans == 'f'</code>. See if you can accomplish this in two different ways."""

colors_df.groupby('is_trans').count()  # one way, data does not look very presentable

colors_df.is_trans.value_counts()  # another way, way more presentable and clear way to show how many counts of each value there is in a df

"""**Challenge**: Change this into an h3 section heading: 
### Understanding LEGO Themes vs. LEGO Sets

Walk into a LEGO store and you will see their products organised by theme. Their themes include Star Wars, Batman, Harry Potter and many more.

**Challenge**: Display this image: https://i.imgur.com/aKcwkSx.png

<img src="https://i.imgur.com/aKcwkSx.png">

A lego set is a particular box of LEGO or product. Therefore, a single theme typically has many different sets.

**Challenge**: Display this image https://i.imgur.com/whB1olq.png

<img src="https://i.imgur.com/whB1olq.png">

The <code>sets.csv</code> data contains a list of sets over the years and the number of parts that each of these sets contained.

**Challenge**: Read the sets.csv data and take a look at the first and last couple of rows.
"""

sets_df = pd.read_csv('data/sets.csv')

sets_df.head()

sets_df.tail()

"""
**Challenge**: In which year were the first LEGO sets released and what were these sets called?"""

sets_df[sets_df['year'] == sets_df.year.min()]  # you can filter datasets by a condition, here we check for all data where the year is equal to the smallest value for year in the df

"""**Challenge**: Find the top 5 LEGO sets with the most number of parts. """

sets_df.sort_values('num_parts', ascending=False).head()

"""**Challenge**: Use <code>.groupby()</code> and <code>.count()</code> to show the number of LEGO sets released year-on-year. How do the number of sets released in 1955 compare to the number of sets released in 2019? """

sets_by_year = sets_df.groupby('year').count() 
sets_by_year.head()  # can see 1955 this way

sets_by_year.set_num.tail()  # can see 2019 this way

"""**Challenge**: Show the number of LEGO releases on a line chart using Matplotlib. <br>
<br>
Note that the .csv file is from late 2020, so to plot the full calendar years, you will have to exclude some data from your chart. Can you use the slicing techniques covered in Day 21 to avoid plotting the last two years? The same syntax will work on Pandas DataFrames. 
"""

plt.figure(figsize=(16,10))
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel("Year", fontsize=14)
plt.ylabel("Number Of Sets Released", fontsize=14)

# index accesses year numbers, [:-1] removes the last entry since 2021 was not over when this dataset released and is misleading data
plt.plot(sets_by_year.index[:-1], sets_by_year.set_num[:-1])

"""### Aggregate Data with the Python .agg() Function

Let's work out the number of different themes shipped by year. This means we have to count the number of unique theme_ids per calendar year.
"""

# agg takes a dictionary as an arg, where we specify the operation we'd like to apply to each column. Here, we calculate the number of unique elements in the theme_id column
# pd.Series is a one-dimensional ndarray with axis labels, it's used to apply the .nunique filter

themes_by_year = sets_df.groupby('year').agg({'theme_id': pd.Series.nunique})
themes_by_year

# give theme_id a more appropriate name, since it is the number of unique themes

themes_by_year.rename(columns = {'theme_id':'nr_themes'}, inplace=True)  # changes theme_id to nr_themes
themes_by_year

"""**Challenge**: Plot the number of themes released by year on a line chart. Only include the full calendar years (i.e., exclude 2020 and 2021). """

plt.figure(figsize=(16,10))
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel("Year", fontsize=14)
plt.ylabel("Number Of Themes Released", fontsize=14)

# index accesses year numbers, [:-1] removes the last entry since 2021 was not over when this dataset released and is misleading data
plt.plot(themes_by_year.index[:-1], themes_by_year.nr_themes[:-1])

"""

### Line Charts with Two Seperate Axes"""

# This looks very bad because the y axis values scale differently

plt.figure(figsize=(16,10))
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel("Year", fontsize=14)
plt.ylabel("Number Of Themes Released", fontsize=14)

plt.plot(themes_by_year.index[:-1], themes_by_year.nr_themes[:-1])
plt.plot(sets_by_year.index[:-1], sets_by_year.set_num[:-1])

plt.figure(figsize=(16,10))

ax1 = plt.gca() # get current axes
ax2 = ax1.twinx() # create another axis that shares the same x-axis

ax1.set_xlabel('Year', fontsize=14)
ax1.set_ylabel('Number of Sets Released', fontsize=14, color="red")  
ax2.set_ylabel('Number of Themes Released', fontsize=14, color="blue")  # you need to set labels independently for the axes now, can't use plt and the function changes

ax1.tick_params(axis='both', labelsize=14)
ax2.tick_params(labelsize=14)  # these are the numbers on the side, need to make them equal size cause the bigger ones automatically become smaller

ax1.plot(sets_by_year.index[:-1], sets_by_year.set_num[:-1], color="red")
ax2.plot(themes_by_year.index[:-1], themes_by_year.nr_themes[:-1], color="blue")

"""**Challenge**: Use the <code>.groupby()</code> and <code>.agg()</code> function together to figure out the average number of parts per set. How many parts did the average LEGO set released in 1954 compared to say, 2017?"""

parts_per_set = sets_df.groupby('year').agg({'num_parts':pd.Series.mean})  # to clarify, pd.Series.mean is a substitute for mean() in the dictionary arg
parts_per_set.head()

parts_per_set.tail()

"""### Scatter Plots in Matplotlib

**Challenge**: Has the size and complexity of LEGO sets increased over time based on the number of parts? Plot the average number of parts over time using a Matplotlib scatter plot. See if you can use the [scatter plot documentation](https://matplotlib.org/3.1.0/api/_as_gen/matplotlib.pyplot.scatter.html) before I show you the solution. Do you spot a trend in the chart?
"""

plt.figure(figsize=(16,10))
plt.xticks(fontsize=14)
plt.yticks(fontsize=14)
plt.xlabel("Year", fontsize=14)
plt.ylabel("Average Number of Parts", fontsize=14)

plt.scatter(parts_per_set.index, parts_per_set.num_parts)

"""### Number of Sets per LEGO Theme

LEGO has licensed many hit franchises from Harry Potter to Marvel Super Heros to many others. But which theme has the largest number of individual sets?
"""

set_theme_count = sets_df.theme_id.value_counts()
set_theme_count

"""**Challenge** Use what you know about HTML markup and tags to display the database schema: https://i.imgur.com/Sg4lcjx.png

<img src="https://i.imgur.com/Sg4lcjx.png">

### Database Schemas, Foreign Keys and Merging DataFrames

The themes.csv file has the actual theme names. The sets .csv has <code>theme_ids</code> which link to the <code>id</code> column in the themes.csv.

**Challenge**: Explore the themes.csv. How is it structured? Search for the name 'Star Wars'. How many <code>id</code>s correspond to this name in the themes.csv? Now use these <code>id</code>s and find the corresponding the sets in the sets.csv (Hint: you'll need to look for matches in the <code>theme_id</code> column)
"""

themes_df = pd.read_csv('data/themes.csv') 
themes_df.head()

themes_df[themes_df.name == 'Star Wars']

sets_df[sets_df.theme_id == 18] #we can see that Star Wars has an id of 18 (and 3 others) so we can search it in the sets table

sets_df[sets_df.theme_id == 158]

sets_df[sets_df.theme_id == 209]

sets_df[sets_df.theme_id == 261]

"""### Merging (i.e., Combining) DataFrames based on a Key

Having to manually search every single theme in the other table is tedious and inconvenient, instead, you can merge the dataframes together and make the process much simpler.
"""

# .merge works with columns of the same name, we are turning set_theme_count into a dataframe with a column called ID

set_theme_count = pd.DataFrame({'id':set_theme_count.index,
                                'set_count':set_theme_count.values})
set_theme_count

merged_df = pd.merge(set_theme_count, themes_df, on='id')  # merge these two dataframes on the id column
merged_df.head()

# only graph the top 10 themes because there are 800+ themes and it would be unreadable as a bar chart

plt.figure(figsize=(14,8))
plt.xticks(fontsize=14, rotation=45)
plt.yticks(fontsize=14)
plt.ylabel('Nr of Sets', fontsize=14)
plt.xlabel('Theme Name', fontsize=14)
 
plt.bar(merged_df.name[:10], merged_df.set_count[:10])