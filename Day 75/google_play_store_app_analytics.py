# -*- coding: utf-8 -*-
"""Google Play Store App Analytics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jQgkwM6CcnOdKMFg-p2iq-9_OA1DfYZu

# Introduction

In this notebook, we will do a comprehensive analysis of the Android app market by comparing thousands of apps in the Google Play store.

# About the Dataset of Google Play Store Apps & Reviews

**Data Source:** <br>
App and review data was scraped from the Google Play Store by Lavanya Gupta in 2018. Original files listed [here](
https://www.kaggle.com/lava18/google-play-store-apps).

# Import Statements
"""

import pandas as pd
import plotly.express as px

"""# Notebook Presentation"""

# Show numeric output in decimal format to two decimal places e.g., 2.15
pd.options.display.float_format = '{:,.2f}'.format

"""# Read the Dataset"""

df_apps = pd.read_csv('apps.csv')

"""# Data Cleaning

**Challenge**: How many rows and columns does `df_apps` have? What are the column names? Look at a random sample of 5 different rows with [.sample()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sample.html).
"""

df_apps.shape

df_apps.columns

df_apps.sample(5) # shows random rows, the number represents the number of rows to show

"""### Drop Unused Columns

**Challenge**: Remove the columns called `Last_Updated` and `Android_Version` from the DataFrame. We will not use these columns. 
"""

df_apps.drop(['Last_Updated', 'Android_Ver'], axis=1, inplace=True)
df_apps.head()

"""### Find and Remove NaN values in Ratings

**Challenge**: How may rows have a NaN value (not-a-number) in the Ratings column? Remove them.
"""

df_apps[df_apps.Rating.isna()].shape  # the first number is the number of rows with no rating

df_apps.dropna(inplace=True)
print(df_apps.isna().any())
df_apps.head()

df_apps.shape # the number of entries we have to work with has reduced alot as we can see

"""### Find and Remove Duplicates

**Challenge**: Are there any duplicates in data? Check for duplicates using the [.duplicated()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.duplicated.html) function. How many entries can you find for the "Instagram" app? Use [.drop_duplicates()](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html) to remove any duplicates from `df_apps_clean`. 

"""

df_apps[df_apps.duplicated()].shape  # first number is the number of duplicate entries

df_apps[df_apps.App == 'Instagram'].shape  # find number of entries for Instagram

df_apps.drop_duplicates(inplace=True)

df_apps[df_apps.App == 'Instagram'].shape  # find number of entries for Instagram, you can see there are still 3 duplicates even though we removed duplicates?

# You need to specify the columns to check for duplicates for, else it compares every single column
 
df_apps.drop_duplicates(subset=['App', 'Type', 'Price'], inplace=True)
df_apps[df_apps.App == 'Instagram'].shape  # find number of entries for Instagram, now there is only 1 entry, duplicates removed

df_apps.shape  # we have even less entries now

"""# Find Highest Rated Apps

**Challenge**: Identify which apps are the highest rated. What problem might you encounter if you rely exclusively on ratings alone to determine the quality of an app?
"""

# the problem with this, an app with 5 stars and 1 review will be rated the same as an app with 5 stars and 10000 reviews, clearly the one with 10000 reviews deserves to be ranked higher
# furthermore, most apps with thousands of reviews are not going to have exactly 5 stars, so by this metric, only smaller apps will rank highly

df_apps.sort_values('Rating', ascending=False).head(10)

"""# Find 5 Largest Apps in terms of Size (MBs)

**Challenge**: What's the size in megabytes (MB) of the largest Android apps in the Google Play Store. Based on the data, do you think there could be limit in place or can developers make apps as large as they please? 
"""

df_apps.sort_values('Size_MBs', ascending=False).head(10)

"""We can assume from the above data that there is a size limit of 100 MB for apps on the google play store.

# Find the 5 App with Most Reviews

**Challenge**: Which apps have the highest number of reviews? Are there any paid apps among the top 50?
"""

df_apps.sort_values('Reviews', ascending=False).head(10)

# are there any free apps in the top 50?

any_paid = df_apps.sort_values('Reviews', ascending=False).head(50)[df_apps.Type=='Paid'].App.any()
print(f"Are there paid apps in the top 50 most reviewed apps: {any_paid}")  # filter top 50 by Type Paid and then check if there are any entries

# Very long line of code, annoying to come back to and decode so, it sorts by reviews, only takes the top 50, filters by type==paid, then filters by 1 column just to make the result
# 1 line instead of 10 columns, and then check for any() entries

"""Result: All 50 of the top apps are free

# Plotly Pie and Donut Charts - Visualise Categorical Data: Content Ratings
"""

ratings = df_apps.Content_Rating.value_counts()  # get the occurences of each type of rating
ratings

fig = px.pie(
    labels=ratings.index, 
    values=ratings.values,
    title='Content Rating',
    names=ratings.index
    )  # this creates a pie chart, ratings.index is the titles of each rating category, ratings.values is the count

fig.update_traces(textposition='outside', textinfo='percent+label')  # traces are graphical marks on a figure in plotly

fig.show()



"""# Numeric Type Conversion: Examine the Number of Installs

**Challenge**: How many apps had over 1 billion (that's right - BILLION) installations? How many apps just had a single install? 

Check the datatype of the Installs column.

Count the number of apps at each level of installations. 

Convert the number of installations (the Installs column) to a numeric data type. Hint: this is a 2-step process. You'll have make sure you remove non-numeric characters first. 
"""

# first we need to change the installs from object datatype to numeric so we can compare

# astype casts the pandas object to the specified datatype, str in this case, then the .str.replace is the function to replace the , to nothing to be able to cast to int
df_apps.Installs = df_apps.Installs.astype(str).str.replace(",", "")
df_apps.Installs = pd.to_numeric(df_apps.Installs)
df_apps[['App', 'Installs']].groupby('Installs').count()

one_billion_plus_installs = df_apps[df_apps.Installs >= 1E9]
one_billion_plus_installs

one_install_apps = df_apps[df_apps.Installs == 1]
one_install_apps

"""# Find the Most Expensive Apps, Filter out the Junk, and Calculate a (ballpark) Sales Revenue Estimate

Let's examine the Price column more closely.

**Challenge**: Convert the price column to numeric data. Then investigate the top 20 most expensive apps in the dataset.

Remove all apps that cost more than $250 from the `df_apps_clean` DataFrame.

Add a column called 'Revenue_Estimate' to the DataFrame. This column should hold the price of the app times the number of installs. What are the top 10 highest grossing paid apps according to this estimate? Out of the top 10 highest grossing paid apps, how many are games?

"""

# change the datatype to int first

df_apps.Price = df_apps.Price.astype(str).str.replace("$", "")  # remove the dollar sign
df_apps.Price = pd.to_numeric(df_apps.Price)

# top 20 most expensive apps

df_apps.sort_values('Price', ascending=False).head(20)

"""As we can see, a popular starting app to create for those learning to create apps called I am Rich dominates the top charts of most expensive apps. While this could be useful data, we are going to get rid of any app that costs over 250$.

### The most expensive apps sub $250
"""

df_apps = df_apps[df_apps.Price < 250]  # only keep values where the price is under 250$

df_apps.sort_values('Price', ascending=False).head(20)

"""### Highest Grossing Paid Apps (ballpark estimate)"""

df_apps['Revenue_Estimate'] = df_apps.Installs.mul(df_apps.Price)  # This should create a new column, and the data will be the installs multiplied by the price

df_apps.sort_values('Revenue_Estimate', ascending=False).head(10)

# downside of this is that this assumes all installs were made at full price, even though apps can go on sale sometimes

"""# Plotly Bar Charts & Scatter Plots: Analysing App Categories"""

df_apps.Category.nunique()

top_10_categories = df_apps.Category.value_counts().head(10)
top_10_categories

"""### Vertical Bar Chart - Highest Competition (Number of Apps)"""

bar = px.bar(
    x = top_10_categories.index,
    y = top_10_categories.values
    )

bar.show()

"""### Horizontal Bar Chart - Most Popular Categories (Highest Downloads)"""

category_installs = df_apps.groupby('Category').agg({'Installs': pd.Series.sum})  # creates a df where categories are the titles of each row and sum of installs for that category is the data
category_installs.sort_values('Installs', ascending=True, inplace=True)

h_bar = px.bar(x = category_installs.Installs,
               y = category_installs.index,
               orientation='h')  # this makes it a horizontal bar
 
h_bar.show()

"""### Category Concentration - Downloads vs. Competition

**Challenge**: 
* First, create a DataFrame that has the number of apps in one column and the number of installs in another:

<img src=https://imgur.com/uQRSlXi.png width="350">

* Then use the [plotly express examples from the documentation](https://plotly.com/python/line-and-scatter/) alongside the [.scatter() API reference](https://plotly.com/python-api-reference/generated/plotly.express.scatter.html)to create scatter plot that looks like this. 

<img src=https://imgur.com/cHsqh6a.png>

*Hint*: Use the size, hover_name and color parameters in .scatter(). To scale the yaxis, call .update_layout() and specify that the yaxis should be on a log-scale like so: yaxis=dict(type='log') 
"""

df_download_competition = df_apps.groupby('Category').agg({'App':pd.Series.count, 'Installs': pd.Series.sum}) # create the dataframe with app count and install sum
df_download_competition.sort_values('Installs', ascending=False, inplace=True)
df_download_competition.head()

scatter = px.scatter(df_download_competition, # data
                    x='App', # column name
                    y='Installs',
                    title='Category Concentration',
                    size='App',
                    hover_name=df_download_competition.index,
                    color='Installs')
 
scatter.update_layout(xaxis_title="Number of Apps (Lower=More Concentrated)",
                      yaxis_title="Installs",
                      yaxis=dict(type='log'))
 
scatter.show()

"""### Explanation:
<img src=https://imgur.com/a/z7sHdIV><br>
https://imgur.com/a/z7sHdIV

# Extracting Nested Data from a Column

**Challenge**: How many different types of genres are there? Can an app belong to more than one genre? Check what happens when you use .value_counts() on a column with nested values? See if you can work around this problem by using the .split() function and the DataFrame's [.stack() method](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.stack.html).
"""

# split the string on the semi colon then stack them

stack = df_apps.Genres.str.split(';', expand=True).stack()
print(f'We now have a single column with shape: {stack.shape}')
num_genres = stack.value_counts()
print(f'Number of genres: {len(num_genres)}')

"""# Colour Scales in Plotly Charts - Competition in Genres

**Challenge**: Can you create this chart with the Series containing the genre data? 

<img src=https://imgur.com/DbcoQli.png width=400>

Try experimenting with the built in colour scales in Plotly. You can find a full list [here](https://plotly.com/python/builtin-colorscales/). 

* Find a way to set the colour scale using the color_continuous_scale parameter. 
* Find a way to make the color axis disappear by using coloraxis_showscale.
"""

bar = px.bar(x = num_genres.index[:15], # index = category name
             y = num_genres.values[:15], # count
             title='Top Genres',
             hover_name=num_genres.index[:15],
             color=num_genres.values[:15],
             color_continuous_scale='Agsunset')
 
bar.update_layout(xaxis_title='Genre',
yaxis_title='Number of Apps',
coloraxis_showscale=False)
 
bar.show()

"""# Grouped Bar Charts: Free vs. Paid Apps per Category"""

print(df_apps.Type.value_counts())

df_free_vs_paid = df_apps.groupby(["Category", "Type"], as_index=False).agg({'App': pd.Series.count})
df_free_vs_paid.head()

"""**Challenge**: Use the plotly express bar [chart examples](https://plotly.com/python/bar-charts/#bar-chart-with-sorted-or-ordered-categories) and the [.bar() API reference](https://plotly.com/python-api-reference/generated/plotly.express.bar.html#plotly.express.bar) to create this bar chart: 

<img src=https://imgur.com/LE0XCxA.png>

You'll want to use the `df_free_vs_paid` DataFrame that you created above that has the total number of free and paid apps per category. 

See if you can figure out how to get the look above by changing the `categoryorder` to 'total descending' as outlined in the documentation here [here](https://plotly.com/python/categorical-axes/#automatically-sorting-categories-by-name-or-total-value). 
"""

g_bar = px.bar(df_free_vs_paid,
               x='Category',
               y='App',
               title='Free vs Paid Apps by Category',
               color='Type',
               barmode='group')
 
g_bar.update_layout(xaxis_title='Category',
                    yaxis_title='Number of Apps',
                    xaxis={'categoryorder':'total descending'},
                    yaxis=dict(type='log'))
 
g_bar.show()

"""# Plotly Box Plots: Lost Downloads for Paid Apps

**Challenge**: Create a box plot that shows the number of Installs for free versus paid apps. How does the median number of installations compare? Is the difference large or small?

Use the [Box Plots Guide](https://plotly.com/python/box-plots/) and the [.box API reference](https://plotly.com/python-api-reference/generated/plotly.express.box.html) to create the following chart. 

<img src=https://imgur.com/uVsECT3.png>

"""

box = px.box(df_apps,
             y='Installs',
             x='Type',
             color='Type',
             notched=True,
             points='all',
             title='How Many Downloads are Paid Apps Giving Up?')
 
box.update_layout(yaxis=dict(type='log'))
 
box.show()

"""# Plotly Box Plots: Revenue by App Category

**Challenge**: See if you can generate the chart below: 

<img src=https://imgur.com/v4CiNqX.png>

Looking at the hover text, how much does the median app earn in the Tools category? If developing an Android app costs $30,000 or thereabouts, does the average photography app recoup its development costs?

Hint: I've used 'min ascending' to sort the categories. 
"""

df_paid_apps = df_apps[df_apps['Type'] == 'Paid']
box = px.box(df_paid_apps, 
             x='Category', 
             y='Revenue_Estimate',
             title='How Much Can Paid Apps Earn?')
 
box.update_layout(xaxis_title='Category',
                  yaxis_title='Paid App Ballpark Revenue',
                  xaxis={'categoryorder':'min ascending'},
                  yaxis=dict(type='log'))
 
 
box.show()

"""# How Much Can You Charge? Examine Paid App Pricing Strategies by Category

**Challenge**: What is the median price price for a paid app? Then compare pricing by category by creating another box plot. But this time examine the prices (instead of the revenue estimates) of the paid apps. I recommend using `{categoryorder':'max descending'}` to sort the categories.
"""

df_paid_apps.Price.median()

box = px.box(df_paid_apps,
             x='Category',
             y="Price",
             title='Price per Category')
 
box.update_layout(xaxis_title='Category',
                  yaxis_title='Paid App Price',
                  xaxis={'categoryorder':'max descending'},
                  yaxis=dict(type='log'))
 
box.show()